---
title: "Bootstrap2"
author: "Marion Boisseaux"
date: "2026-02-02"
output: html_document
---

##Notes

The script uses a function called *mybootPX* which is adapted from Gavin's R package *hydrafit* for estimating parameters for functions of plant hydraulic vulnerability : https://github.com/brownegm/hydrafit

*boot_vals* = distribution of all P50 values recalculated. 

*boot_mean* = mean of bootstrap values, which can be biased by the distribution queue

*boot_median* = median of bootstrap values (usually more robust).

*boot_se* = standard error of bootstrap values, estimator uncertainty

*margin_error* = t_score Ã— boot_se, width of confidence interval (95%).

*conf.low / conf.high* = confidence interval around the "observed value", value from the best fit model.


#Library
```{r}
# devtools::install_github("brownegm/hydrafit", force= T)
# install.packages("here")

library(hydrafit)
library(ggplot2)
library(agricolae)
library(plyr)
library(multcomp)
library(corrplot)
library(factoextra)
library(readxl)
library(dplyr)
library(ggpubr)
library(cowplot)
library(tidyr)
library(readr)
library(stringr)
library(tibble)
library(purrr)
library(readr)
library(FSA)

```


# Functions

## conversion

```{r}
se <- function(x, na.rm = T){
  sd(x, na.rm = na.rm)/sqrt(length(x))
}

#Convert function to Marvin/Hydrafit structure in order to use the BootPX function

model_map <- c(
  "Sigmoidal"   = "sig",
  "Logistic"   = "log",
  "Exponential"= "exp",
  "Exponential2" = "exp2",
  "Linear"     = "Linear"
)

convert <- function(fit) {

  s  <- fit$summary
  bp <- fit$best_pars
  se <- fit$std_errs
  
  mod_code <- unname(model_map[s$model])

# --- UNIVERSAL PARAMETER MAPPING ---

A <- bp$A
B <- bp$B
sterrorA <- se$A
sterrorB <- se$B

# CASE 1: 4-parameter model (Logistic / Sigmoidal)
if (!is.null(bp$Xo) || !is.null(bp$C)) {

  if (!is.null(bp$C)) {
    C <- bp$C
    sterrorC <- se$C
  } else {
    C <- bp$Xo
    sterrorC <- se$Xo
  }

  D <- bp$sd
  sterrorD <- se$sd

}

# CASE 2: 3-parameter model (Exponential family)
else if (!is.null(bp$sd) && length(bp) == 3) {

  C <- bp$sd
  sterrorC <- se$sd

  D <- NA
  sterrorD <- NA
}

else {
  stop("Model structure not recognized.")
}

  # --- BUILD OUTPUT ---
  out <- list(
    species = s$Species,
    data.type = mod_code,

    A = A,
    B = B,
    C = C,
    D = D,

    loglikeli = s$loglikeli,
    rsq = s$rsq,
    slope = s$slope,
    AIC = s$AIC,
    AICcorr = s$AICcorr,

    sterrorA = sterrorA,
    sterrorB = sterrorB,
    sterrorC = sterrorC,
    sterrorD = sterrorD,

    vcov = fit$vcov,
    N = s$N,

    maxCond = s$Kmax,
    psi_k20 = s$psi_kleaf20,
    psi_k50 = s$psi_kleaf50,
    psi_k80 = s$psi_kleaf80,
    psi_k95 = s$psi_kleaf95,

    max_cond_at0.1 = s$Kmax_at_0.1MPa,
    psi_k20_at0.1 = s$psi_kleaf20,
    psi_k50_at0.1 = s$psi_kleaf50,
    psi_k80_at0.1 = s$psi_kleaf80,
    psi_k95_at0.1 = s$psi_kleaf95,

    plot = NULL,
    models_within_2AIC = NA
  )

  attr(out, "mod.type") <- mod_code
  attr(out, "fit.list") <- FALSE

  return(out)
}
```

#Conductance - gs
```{r}
# Load all model fitting results (RDS file containing previously computed model fits). This is done using the following script: "Script for curve fit - AIC and parameters-Boisseaux/Browne
all_results_r <- readRDS("C:/Users/marion.boisseaux/Dropbox/Mon PC (Jaboty20)/Post_doc_CalState_LA/Amber/HydraulicSeasonVariation/results/model_fitting_results_gs.RDS") 

# Select the specific subset of models corresponding to X fits for Stomatal conductance (gs)
gs_summer <- c(all_results_r[1], all_results_r[14], all_results_r[21], all_results_r[33], all_results_r[43], all_results_r[54])

gs_spring <- c(all_results_r[6], all_results_r[19], all_results_r[29], all_results_r[39], all_results_r[49], all_results_r[59])

##Convert model structure into Hydrafit format for each species
#summer
plra_fit_summer <- convert(gs_summer$PLRA_Summer_Exponential)
rica_fit_summer <- convert(gs_summer$RICA_Summer_Logistic)
sala_fit_summer <- convert(gs_summer$SALA_Summer_Sigmoidal)
cecr_fit_summer <- convert(gs_summer$CECR_Summer_Exponential)
quag_fit_summer <- convert(gs_summer$QUAG_Summer_Logistic)
umca_fit_summer <- convert(gs_summer$UMCA_Summer_Sigmoidal)

#spring
plra_fit_spring <- convert(gs_spring$PLRA_spring_Exponential)
rica_fit_spring <- convert(gs_spring$RICA_spring_Sigmoidal)
sala_fit_spring <- convert(gs_spring$SALA_spring_Sigmoidal)
cecr_fit_spring <- convert(gs_spring$CECR_spring_Sigmoidal)
quag_fit_spring <- convert(gs_spring$QUAG_spring_Sigmoidal)
umca_fit_spring <- convert(gs_spring$UMCA_spring_Sigmoidal)

# Perform bootstrap analysis
#summer
plra_boot_summer <- bootPX(fit = plra_fit_summer, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
rica_boot_summer <- bootPX(fit = rica_fit_summer, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
sala_boot_summer <- bootPX(fit = sala_fit_summer, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
cecr_boot_summer <- bootPX(fit = cecr_fit_summer, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
quag_boot_summer <- bootPX(fit = quag_fit_summer, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
umca_boot_summer <- bootPX(fit = umca_fit_summer, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)

#spring
plra_boot_spring <- bootPX(fit = plra_fit_spring, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
rica_boot_spring <- bootPX(fit = rica_fit_spring, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
sala_boot_spring <- bootPX(fit = sala_fit_spring, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
cecr_boot_spring <- bootPX(fit = cecr_fit_spring, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
quag_boot_spring <- bootPX(fit = quag_fit_spring, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
umca_boot_spring <- bootPX(fit = umca_fit_spring, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)

# Combine all bootstrap results into a single list for easier handling
boot_list_summer <- list(
  plra = plra_boot_summer,
  rica = rica_boot_summer,
  sala = sala_boot_summer,
  cecr = cecr_boot_summer,
  quag = quag_boot_summer,
  umca = umca_boot_summer)

boot_list_spring <- list(
  plra = plra_boot_spring,
  rica = rica_boot_spring,
  sala = sala_boot_spring,
  cecr = cecr_boot_spring,
  quag = quag_boot_spring,
  umca = umca_boot_spring)


make_boot_table <- function(boot_list, season_name) {
  purrr::map_dfr(boot_list, function(x) {
    tibble::tibble(
      Species = x$species,
      Season = season_name,
      psi_PX = x$psi_PX,
      boot_mean = x$boot_mean,
      boot_median = x$boot_median,
      boot_se = x$boot_se,
      margin_error = x$margin_error,
      px_est = x$px_est,
      conf.low = x$conf.low,
      conf.high = x$conf.high
    )
  })
}

boot_table_gs <- dplyr::bind_rows(
  make_boot_table(boot_list_summer, "Summer"),
  make_boot_table(boot_list_spring, "Spring")
)

boot_table_gs

# Save the bootstrap summary table to a CSV file
write.csv(x = boot_table_gs, file = "C:/Users/marion.boisseaux/Dropbox/Mon PC (Jaboty20)/Post_doc_CalState_LA/Amber/HydraulicSeasonVariation/results/boottablegs.csv")


library(ggplot2)

fig1 <- ggplot(boot_table_gs %>% filter(boot_mean < 10), 
       aes(x = Season, y = boot_mean, color = Species)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2) +
  theme_minimal() +
  ylab("Psi at 50% loss gs") +
  ggtitle("Seasonal gs50 shifts per species")

#get only species that have CI not overlapping between seasons
sig_species <- boot_table_gs %>%
  select(Species, Season, conf.low, conf.high) %>%
  pivot_wider(names_from = Season,
              values_from = c(conf.low, conf.high)) %>%
  mutate(sig = (conf.low_Spring > conf.high_Summer) |
               (conf.low_Summer > conf.high_Spring)) %>%
  filter(sig == T) %>%
  pull(Species)

#create label variable
boot_table_gs2 <- boot_table_gs %>%
  mutate(Species_label = ifelse(Species %in% sig_species,
                                paste0(Species, " *"),
                                Species))
#plot
fig2 <-ggplot(boot_table_gs2 %>% filter(boot_mean < 10),
       aes(x = Season, y = boot_mean, group = Species)) +
  geom_point(aes(color = Season), size = 3) +
  geom_line(color = "grey40", linewidth = 0.8) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high),
                width = 0.15) +
  facet_wrap(~ Species_label) +
  scale_color_manual(values = c("Spring" = "#2E8B57",
                                "Summer" = "#E69F00")) +
  theme_minimal() +
  ylab("gs50") +
  ggtitle("Seasonal gs50 shifts within species\n* = non-overlapping confidence intervals")

ggsave(filename = "fig1.jpeg", plot = fig1)
ggsave(filename = "fig2.jpeg", plot = fig2)

```

#Kleaf - ca marche mais c'est en fait gs
```{r}
# Load all model fitting results (RDS file containing previously computed model fits). This is done using the following script: "Script for curve fit - AIC and parameters-Boisseaux/Browne
all_results_kleaf <- readRDS("C:/Users/marion.boisseaux/Dropbox/Mon PC (Jaboty20)/Post_doc_CalState_LA/Amber/HydraulicSeasonVariation/results/model_fitting_results_kleaf.RDS") 

# Select the specific subset of models corresponding to X fits for Stomatal conductance (kleaf)
kleaf_summer <- c(all_results_kleaf[1], 
                  all_results_kleaf[13],
                  all_results_kleaf[21], 
                  all_results_kleaf[32], 
                  all_results_kleaf[41],
                  all_results_kleaf[52])

kleaf_spring <- c(all_results_kleaf[8], 
                  all_results_kleaf[17],
                  all_results_kleaf[26], 
                  all_results_kleaf[36], 
                  all_results_kleaf[46],
                  all_results_kleaf[56] )

##Convert model structure into Hydrafit format for each species
#summer
plra_fit_summer <- convert(kleaf_summer$PLRA_Summer_Exponential2)
rica_fit_summer <- convert(kleaf_summer$RICA_Summer_Exponential2)
sala_fit_summer <- convert(kleaf_summer$SALA_Summer_Exponential)
cecr_fit_summer <- convert(kleaf_summer$CECR_Summer_Exponential)
quag_fit_summer <- convert(kleaf_summer$QUAG_Summer_Logistic)
umca_fit_summer <- convert(kleaf_summer$UMCA_Summer_Exponential)

#spring
plra_fit_spring <- convert(kleaf_spring$PLRA_Spring_Exponential)
rica_fit_spring <- convert(kleaf_spring$RICA_Spring_Exponential)
sala_fit_spring <- convert(kleaf_spring$SALA_Spring_Exponential)
cecr_fit_spring <- convert(kleaf_spring$CECR_Spring_Exponential)
quag_fit_spring <- convert(kleaf_spring$QUAG_Spring_Exponential2)
umca_fit_spring <- convert(kleaf_spring$UMCA_Spring_Logistic)

# Perform bootstrap analysis
#summer
plra_boot_summer <- bootPX(fit = plra_fit_summer, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
rica_boot_summer <- bootPX(fit = rica_fit_summer, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
sala_boot_summer <- bootPX(fit = sala_fit_summer, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
cecr_boot_summer <- bootPX(fit = cecr_fit_summer, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
quag_boot_summer <- bootPX(fit = quag_fit_summer, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
umca_boot_summer <- bootPX(fit = umca_fit_summer, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)

#spring
plra_boot_spring <- bootPX(fit = plra_fit_spring, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
rica_boot_spring <- bootPX(fit = rica_fit_spring, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
sala_boot_spring <- bootPX(fit = sala_fit_spring, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
cecr_boot_spring <- bootPX(fit = cecr_fit_spring, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
quag_boot_spring <- bootPX(fit = quag_fit_spring, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)
umca_boot_spring <- bootPX(fit = umca_fit_spring, px = 0.5, psi_max = 0.1, sims = 1000, seed = 123,  margin = "quantile",  pairwise = FALSE)

# Combine all bootstrap results into a single list for easier handling
boot_list_summer <- list(
  plra = plra_boot_summer,
  rica = rica_boot_summer,
  sala = sala_boot_summer,
  cecr = cecr_boot_summer,
  quag = quag_boot_summer,
  umca = umca_boot_summer)

boot_list_spring <- list(
  plra = plra_boot_spring,
  rica = rica_boot_spring,
  sala = sala_boot_spring,
  cecr = cecr_boot_spring,
  quag = quag_boot_spring,
  umca = umca_boot_spring)


make_boot_table <- function(boot_list, season_name) {
  purrr::map_dfr(boot_list, function(x) {
    tibble::tibble(
      Species = x$species,
      Season = season_name,
      psi_PX = x$psi_PX,
      boot_mean = x$boot_mean,
      boot_median = x$boot_median,
      boot_se = x$boot_se,
      margin_error = x$margin_error,
      px_est = x$px_est,
      conf.low = x$conf.low,
      conf.high = x$conf.high
    )
  })
}

boot_table_kleaf <- dplyr::bind_rows(
  make_boot_table(boot_list_summer, "Summer"),
  make_boot_table(boot_list_spring, "Spring")
)

boot_table_kleaf

# Save the bootstrap summary table to a CSV file
write.csv(x = boot_table_kleaf, file = "C:/Users/marion.boisseaux/Dropbox/Mon PC (Jaboty20)/Post_doc_CalState_LA/Amber/HydraulicSeasonVariation/results/boottablekleaf.csv")

#plot
fig3 <- ggplot(boot_table_kleaf,
       aes(x = Season, y = boot_mean, color = Species)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high), width = 0.2) +
  theme_minimal() +
  ylab("Psi at 50% loss Kleaf") +
  ggtitle("Seasonal Kleaf50 shifts per species")

#get only species that have CI not overlapping between seasons
sig_species <- boot_table_kleaf %>%
  select(Species, Season, conf.low, conf.high) %>%
  pivot_wider(names_from = Season,
              values_from = c(conf.low, conf.high)) %>%
  mutate(sig = (conf.low_Spring > conf.high_Summer) |
               (conf.low_Summer > conf.high_Spring)) %>%
  filter(sig == T) %>%
  pull(Species)

#create label variable
boot_table_kleaf2 <- boot_table_kleaf %>%
  mutate(Species_label = ifelse(Species %in% sig_species,
                                paste0(Species, " *"),
                                Species))
#plot
fig4<- ggplot(boot_table_kleaf2 %>% filter(boot_mean < 10),
       aes(x = Season, y = boot_mean, group = Species)) +
  geom_point(aes(color = Season), size = 3) +
  geom_line(color = "grey40", linewidth = 0.8) +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high),
                width = 0.15) +
  facet_wrap(~ Species_label) +
  scale_color_manual(values = c("Spring" = "#2E8B57",
                                "Summer" = "#E69F00")) +
  theme_minimal() +
  ylab("Kleaf50") +
  ggtitle("Seasonal Kleaf50 shifts within species\n* = non-overlapping confidence intervals")

ggsave(filename = "fig3.jpeg", plot = fig3)
ggsave(filename = "fig4.jpeg", plot = fig4)
```
